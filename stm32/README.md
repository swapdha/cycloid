# Cycloid STM32 code

This code was mostly generated by the STM32CubeMX utility; the actual code that
does anything is in Src/main.c.

This code is for the Cycloid HAT board: https://easyeda.com/a1k0n/cycloid

It exposes an I2C device on address 0x75 and is also available via the serial
port; in fact, it will send a heartbeat on the serial port every 10ms, just as
it generates the PWM pulse for the servo and speed controller. This way, a
control loop on the Raspberry Pi can be synchronized with the actual pulses
sent to the car hardware.

## Compiling the code

Install `arm-none-eabi-gcc` on your host platform and type `make`. Copy
build/cycloidp1.1.elf to the Pi and you can flash it right on there.

## Flashing the code

The Raspberry Pi can reflash the code on the HAT using
[OpenOCD](http://openocd.org/). Raspbian has an `openocd` package, but it isn't
new enough to work using the Pi's own GPIO pins. Adafruit has a [guide to
compiling
OpenOCD](https://learn.adafruit.com/programming-microcontrollers-using-openocd-on-raspberry-pi/compiling-openocd)
which will get you up to speed. Once you have it installed, use the
`openocd.cfg` here (or modify it for your needs; it's looking for
`cycloidp1.1.elf` in the current working directory) and `sudo openocd -f openocd.cfg`. If you see
```
...

** Verify Started **
verified 8348 bytes in 0.035556s (229.282 KiB/s)
** Verified OK **
adapter speed: 1001 kHz
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
```

then it worked, and you can hit ^C, or if you really want to you can connect up
gdb and poke around.

## I2C addresses

`i2cdump 1 0x75` will show the "registers" exposed by the I2C slave; the first
three addresses can be written to. The `i2cset` / `i2cget` utilities also work.

| Address | Datatype | Function | Read/write |
|-|-|-|-|
| 0x00 | uint8 | Bits 0 and 1 are the red and green LEDs | R/W |
| 0x01 | int8 | Servo position, (-128..127) | R/W |
| 0x02 | int8 | Speed controller position, (-128..127) | R/W |
| 0x03-0x04 | uint16 little-endian | Cumulative motor encoder ticks | R |
| 0x05-0x06 | uint16 little-endian | Motor period, microseconds per tick or 0 if stopped | R |

There are three "encoder ticks" per motor revolution (it's counting the falling
edge of each of the three motor phase windings).

Cumulative encoder ticks wraps at 65536, naturally; just subtract the previous
reading from the current one to get the number of ticks since last reading.
This can be used to determine distance travelled (divide by 3\*total gear ratio,
multiply by wheel circumference).

Motor period gives you the inverse motor velocity; if the field is nonzero,
divide 1000000 / period to get velocity in ticks/second.

## Serial format

The serial protocol sends a 6-byte packet every 10ms at 115200 baud, 8 data
bits, 1 stop bit, no parity:

| Offset | Value | Description |
|-|-|-|
| 0 | 0xAA | sync marker |
| 1-2 | motor encoder ticks (uint16le) | same as address 0x03-0x04 from I2C registers |
| 3-4 | motor encoder period (uint16le) | same as address 0x05-0x06 from I2C registers |
| 5 | checksum | one's complement of sum of bytes 0..4 |

It accepts 5-byte packets:

| Offset | Value | Description |
|-|-|-|
| 0 | 0x55 | Sync marker |
| 1 | LED flags | same as address 0x00 in I2C registers |
| 2 | servo position (int8) | same as address 0x01 |
| 3 | ESC position (int8) | same as address 0x02 |
| 4 | checksum | one's complement of sum of bytes 0..3 |

If the receiver's checksum doesn't match, it will respond with 0xFE (if it was
not already transmitting a packet; otherwise it will silently ignore the input)

